#!/bin/bash
#==============================================================================
# Package Installer Template
#
# Copy this file to create a new package installer.
# Replace PACKAGE_NAME, GITHUB_REPO, and implement the functions.
#
# Usage: ./package-name.sh [install|update|verify|version]
#==============================================================================

set -e
set -u
set -o pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"

# Source shared libraries
source "${SCRIPT_DIR}/../lib/core.sh"
source "${SCRIPT_DIR}/../lib/version.sh"
source "${SCRIPT_DIR}/../lib/lock.sh"
source "${SCRIPT_DIR}/../lib/health.sh"
source "${SCRIPT_DIR}/../lib/dryrun.sh"

#==============================================================================
# Package Configuration
#==============================================================================

PACKAGE_NAME="example"
GITHUB_REPO="owner/repo"
INSTALL_PATH="/usr/local/bin/${PACKAGE_NAME}"

#==============================================================================
# Package Functions (implement these)
#==============================================================================

# Check if package is installed
is_installed() {
    command_exists "$PACKAGE_NAME"
}

# Get installed version
get_installed_version() {
    if is_installed; then
        "$PACKAGE_NAME" --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+(\.[0-9]+)?' | head -1
    fi
}

# Get desired version from config
get_desired_version() {
    # Load config
    if [[ -f "${PROJECT_ROOT}/config.env" ]]; then
        source "${PROJECT_ROOT}/config.env"
    fi

    local var_name="PACKAGE_${PACKAGE_NAME^^}_VERSION"
    local version="${!var_name:-latest}"

    if [[ "$version" == "latest" ]]; then
        resolve_version "latest" "$GITHUB_REPO"
    else
        echo "$version"
    fi
}

# Install the package
do_install() {
    local version="$1"
    local arch
    arch=$(get_github_arch)

    log_info "Installing ${PACKAGE_NAME} ${version}..."

    # Download URL (customize per package)
    local url="https://github.com/${GITHUB_REPO}/releases/download/v${version}/${PACKAGE_NAME}_${version}_linux_${arch}.tar.gz"

    # Download and extract
    local tmp_dir
    tmp_dir=$(mktemp -d)
    trap "rm -rf $tmp_dir" EXIT

    download_or_print "$url" "${tmp_dir}/package.tar.gz"

    if ! is_dry_run; then
        tar -xzf "${tmp_dir}/package.tar.gz" -C "$tmp_dir"
        install_or_print "${tmp_dir}/${PACKAGE_NAME}" "$INSTALL_PATH"
    fi

    # Update lock file
    update_lock "$PACKAGE_NAME" "$version"
}

# Verify installation
verify() {
    if ! is_installed; then
        health_fail "$PACKAGE_NAME" "not installed"
        return 1
    fi

    local version
    version=$(get_installed_version)
    if [[ -n "$version" ]]; then
        health_pass "$PACKAGE_NAME" "v${version}"
    else
        health_warn "$PACKAGE_NAME" "installed but version unknown"
    fi
    return 0
}

# Create shell configuration
create_shell_config() {
    local config_dir="${HOME}/.config/shell"
    local config_file="${config_dir}/35-${PACKAGE_NAME}.sh"

    mkdir_or_print "$config_dir"

    local content="# ${PACKAGE_NAME} configuration
# Generated by ${PACKAGE_NAME}.sh

alias example='${PACKAGE_NAME}'
"
    write_or_print "$config_file" "$content"
}

#==============================================================================
# Main Logic
#==============================================================================

main() {
    parse_dry_run_flag "$@"

    local action="${1:-install}"

    # Check if enabled in config
    if [[ -f "${PROJECT_ROOT}/config.env" ]]; then
        source "${PROJECT_ROOT}/config.env"
    fi
    local enabled_var="PACKAGE_${PACKAGE_NAME^^}_ENABLED"
    local enabled="${!enabled_var:-true}"

    if [[ "$enabled" != "true" ]]; then
        log_info "${PACKAGE_NAME} is disabled in config"
        return 0
    fi

    case "$action" in
        install)
            local desired_version
            desired_version=$(get_desired_version)

            if is_installed; then
                local current_version
                current_version=$(get_installed_version)
                log_info "${PACKAGE_NAME} already installed: v${current_version}"

                if needs_update "$current_version" "$desired_version"; then
                    log_info "Update available: v${current_version} -> v${desired_version}"
                    do_install "$desired_version"
                else
                    log_success "${PACKAGE_NAME} is up to date"
                fi
            else
                do_install "$desired_version"
            fi

            create_shell_config
            verify
            ;;

        update)
            main install "$@"
            ;;

        verify)
            verify
            ;;

        version)
            if is_installed; then
                get_installed_version
            else
                echo "not installed"
                return 1
            fi
            ;;

        *)
            echo "Usage: $0 [install|update|verify|version] [--dry-run]"
            exit 1
            ;;
    esac

    if is_dry_run; then
        print_dry_run_summary
    fi
}

# Run if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
