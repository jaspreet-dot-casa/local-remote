#!/bin/bash
#==============================================================================
# Lock File Library - Track installed package versions
#
# Usage: source "${SCRIPT_DIR}/lib/lock.sh"
#
# Lock file format (installed.lock):
#   # Generated by cloud-init install
#   # Last updated: 2024-12-22T10:30:00Z
#   LOCK_LAZYGIT=0.40.2
#   LOCK_STARSHIP=1.17.1
#==============================================================================

# Prevent double-sourcing
if [[ -n "${_LIB_LOCK_SOURCED:-}" ]]; then
    return 0
fi
_LIB_LOCK_SOURCED=1

# Source core library if not already sourced
SCRIPT_DIR_LOCK="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck disable=SC1091
source "${SCRIPT_DIR_LOCK}/core.sh"

#==============================================================================
# Lock File Configuration
#==============================================================================

# Get the lock file path
get_lock_file() {
    local project_root
    project_root="$(get_project_root)"
    echo "${project_root}/installed.lock"
}

#==============================================================================
# Lock File Operations
#==============================================================================

# Initialize lock file if it doesn't exist
init_lock_file() {
    local lock_file
    lock_file="$(get_lock_file)"

    if [[ ! -f "$lock_file" ]]; then
        cat > "$lock_file" << EOF
#!/bin/bash
# Generated by cloud-init install
# Last updated: $(date -Iseconds)
# DO NOT EDIT MANUALLY - managed by scripts/cloud-init/

EOF
        log_debug "Initialized lock file: $lock_file"
    fi
}

# Update or add a package version in the lock file
# Usage: update_lock "lazygit" "0.40.2"
update_lock() {
    local package="$1"
    local version="$2"
    local lock_file
    lock_file="$(get_lock_file)"

    init_lock_file

    # Convert package name to uppercase for variable name
    local var_name="LOCK_${package^^}"
    # Replace hyphens with underscores
    var_name="${var_name//-/_}"

    # Check if entry already exists
    if grep -q "^${var_name}=" "$lock_file" 2>/dev/null; then
        # Update existing entry
        sed -i.bak "s/^${var_name}=.*/${var_name}=${version}/" "$lock_file"
        rm -f "${lock_file}.bak"
        log_debug "Updated lock: ${var_name}=${version}"
    else
        # Add new entry
        echo "${var_name}=${version}" >> "$lock_file"
        log_debug "Added lock: ${var_name}=${version}"
    fi

    # Update timestamp
    sed -i.bak "s/^# Last updated:.*/# Last updated: $(date -Iseconds)/" "$lock_file"
    rm -f "${lock_file}.bak"
}

# Get locked version for a package
# Usage: version=$(get_lock "lazygit")
get_lock() {
    local package="$1"
    local lock_file
    lock_file="$(get_lock_file)"

    if [[ ! -f "$lock_file" ]]; then
        return 1
    fi

    # Convert package name to uppercase for variable name
    local var_name="LOCK_${package^^}"
    var_name="${var_name//-/_}"

    # Extract version from lock file
    grep "^${var_name}=" "$lock_file" 2>/dev/null | cut -d'=' -f2
}

# Remove a package from the lock file
# Usage: remove_lock "lazygit"
remove_lock() {
    local package="$1"
    local lock_file
    lock_file="$(get_lock_file)"

    if [[ ! -f "$lock_file" ]]; then
        return 0
    fi

    # Convert package name to uppercase for variable name
    local var_name="LOCK_${package^^}"
    var_name="${var_name//-/_}"

    sed -i.bak "/^${var_name}=/d" "$lock_file"
    rm -f "${lock_file}.bak"
    log_debug "Removed lock: ${var_name}"
}

# Load all locked versions into shell variables
# Usage: load_locks; echo "$LOCK_LAZYGIT"
load_locks() {
    local lock_file
    lock_file="$(get_lock_file)"

    if [[ -f "$lock_file" ]]; then
        # Source the lock file (it's shell-syntax compatible)
        # shellcheck disable=SC1090
        source "$lock_file"
        log_debug "Loaded lock file: $lock_file"
    fi
}

# Verify installed versions match lock file
# Returns 0 if all match, 1 if any mismatch
# Usage: verify_locks
verify_locks() {
    local lock_file
    lock_file="$(get_lock_file)"
    local mismatches=0

    if [[ ! -f "$lock_file" ]]; then
        log_warning "No lock file found"
        return 1
    fi

    log_info "Verifying installed versions against lock file..."

    while IFS='=' read -r var_name locked_version; do
        # Skip comments and empty lines
        [[ "$var_name" =~ ^#.*$ || -z "$var_name" ]] && continue

        # Extract package name from variable name (LOCK_LAZYGIT -> lazygit)
        local package="${var_name#LOCK_}"
        package="${package,,}"  # lowercase
        package="${package//_/-}"  # underscores to hyphens

        # Try to get installed version (package script should provide this)
        local installed_version=""
        if command_exists "$package"; then
            # Try common version flags
            installed_version=$("$package" --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
        fi

        if [[ -n "$installed_version" ]]; then
            if [[ "$installed_version" == "$locked_version" ]]; then
                log_success "$package: $installed_version (matches lock)"
            else
                log_warning "$package: $installed_version (lock: $locked_version)"
                ((mismatches++))
            fi
        else
            log_warning "$package: not found or version unknown (lock: $locked_version)"
            ((mismatches++))
        fi
    done < "$lock_file"

    return "$mismatches"
}

# List all locked packages
# Usage: list_locks
list_locks() {
    local lock_file
    lock_file="$(get_lock_file)"

    if [[ ! -f "$lock_file" ]]; then
        log_info "No lock file found"
        return 0
    fi

    log_section "Locked Package Versions"
    while IFS='=' read -r var_name version; do
        # Skip comments and empty lines
        [[ "$var_name" =~ ^#.*$ || -z "$var_name" ]] && continue

        # Extract package name
        local package="${var_name#LOCK_}"
        package="${package,,}"
        package="${package//_/-}"

        printf "  %-20s %s\n" "$package" "$version"
    done < "$lock_file"
}

# Export lock file to JSON format
# Usage: export_locks_json > locks.json
export_locks_json() {
    local lock_file
    lock_file="$(get_lock_file)"

    if [[ ! -f "$lock_file" ]]; then
        echo "{}"
        return 0
    fi

    echo "{"
    local first=true
    while IFS='=' read -r var_name version; do
        # Skip comments and empty lines
        [[ "$var_name" =~ ^#.*$ || -z "$var_name" ]] && continue

        # Extract package name
        local package="${var_name#LOCK_}"
        package="${package,,}"
        package="${package//_/-}"

        if [[ "$first" == "true" ]]; then
            first=false
        else
            echo ","
        fi
        printf '  "%s": "%s"' "$package" "$version"
    done < "$lock_file"
    echo ""
    echo "}"
}
