#cloud-config
# Ubuntu Server Cloud-Init Configuration
#
# This template is processed by generate.sh to create the final cloud-init.yaml
# Variables are substituted from secrets.env and config.env
#
# Usage:
#   1. Copy secrets.env.template to secrets.env and fill in values
#   2. Run: ./generate.sh
#   3. Use cloud-init.yaml for provisioning

# =============================================================================
# User Configuration
# =============================================================================

users:
  - name: ${USERNAME}
    groups: sudo, docker
    shell: /bin/zsh
    sudo: ALL=(ALL) NOPASSWD:ALL
    lock_passwd: false
    ssh_authorized_keys:
      - ${SSH_PUBLIC_KEY}

# =============================================================================
# System Configuration
# =============================================================================

hostname: ${HOSTNAME}
timezone: UTC
locale: en_US.UTF-8

# Disable root login
disable_root: true

# =============================================================================
# Package Installation
# =============================================================================

package_update: true
package_upgrade: true

packages:
  - curl
  - wget
  - git
  - zsh
  - tree
  - jq
  - htop
  - unzip
  - build-essential
  - ca-certificates
  - gnupg
  - apt-transport-https

# =============================================================================
# Write Files
# =============================================================================

write_files:
  # Clone script - downloads and runs the setup
  - path: /opt/local-remote/bootstrap.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e

      # These values are substituted at generation time
      CLONE_URL="${REPO_URL}"
      CLONE_BRANCH="${REPO_BRANCH}"
      CLONE_USER="${USERNAME}"
      CLONE_DIR="/home/$CLONE_USER/local-remote"

      echo "=== Cloud-Init Bootstrap ==="
      echo "Repository: $CLONE_URL"
      echo "Branch: $CLONE_BRANCH"
      echo "Install directory: $CLONE_DIR"

      # Clone repository
      if [[ -d "$CLONE_DIR" ]]; then
          echo "Directory exists, pulling latest..."
          cd "$CLONE_DIR"
          git pull
      else
          echo "Cloning repository..."
          git clone -b "$CLONE_BRANCH" "$CLONE_URL" "$CLONE_DIR"
      fi

      # Set ownership
      chown -R "$CLONE_USER:$CLONE_USER" "$CLONE_DIR"

      # Run installation as user
      echo "Running installation..."
      cd "$CLONE_DIR/ubuntu1-1"
      sudo -u "$CLONE_USER" bash scripts/cloud-init/install-all.sh -y

      echo "=== Bootstrap Complete ==="

  # Config file (created in final stage after user exists)
  - path: /home/${USERNAME}/.local-remote/config.env
    permissions: '0600'
    defer: true
    content: |
      # Cloud-init generated configuration
      USER_NAME="${USER_NAME}"
      USER_EMAIL="${USER_EMAIL}"
      USER_USERNAME="${USERNAME}"

      GIT_DEFAULT_BRANCH="main"
      GIT_PUSH_AUTO_SETUP_REMOTE=true
      GIT_PULL_REBASE=true
      GIT_PAGER="delta"

      TAILSCALE_SSH_ENABLED=true
      TAILSCALE_EXIT_NODE_ADVERTISE=true
      TAILSCALE_SSH_CHECK_PERIOD="12h"

  # Tailscale auth key (if provided, created in final stage after user exists)
  - path: /home/${USERNAME}/.local-remote/tailscale-auth-key
    permissions: '0600'
    defer: true
    content: |
      ${TAILSCALE_AUTH_KEY}

  # Tailscale authentication script
  - path: /opt/local-remote/setup-tailscale.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      # Authenticate Tailscale if auth key is provided
      set -e
      AUTH_KEY_FILE="/home/${USERNAME}/.local-remote/tailscale-auth-key"
      AUTH_KEY=$(cat "$AUTH_KEY_FILE" 2>/dev/null | tr -d '[:space:]')
      if [[ -n "$AUTH_KEY" && "$AUTH_KEY" != '${TAILSCALE_AUTH_KEY}' ]]; then
        echo "Authenticating Tailscale with provided auth key..."
        tailscale up --ssh --advertise-exit-node --authkey="$AUTH_KEY"
        rm -f "$AUTH_KEY_FILE"
        echo "Tailscale authenticated successfully"
      else
        echo "No Tailscale auth key provided, skipping authentication"
      fi

  # Post-login authentication script
  # Run this after first login to set up Tailscale and Git SSH
  - path: /usr/local/bin/local-remote-login
    permissions: '0755'
    content: |
      #!/bin/bash
      # local-remote-login - Post-login authentication setup
      # Run this after first login to set up Tailscale and Git SSH
      set -e
      set -u
      set -o pipefail

      RED='\033[0;31m'
      GREEN='\033[0;32m'
      YELLOW='\033[1;33m'
      BLUE='\033[0;34m'
      BOLD='\033[1m'
      NC='\033[0m'

      log_info()    { echo -e "${BLUE}→ $1${NC}"; }
      log_success() { echo -e "${GREEN}✓ $1${NC}"; }
      log_warning() { echo -e "${YELLOW}⚠ $1${NC}"; }
      log_error()   { echo -e "${RED}✗ $1${NC}" >&2; }

      log_section() {
          echo ""
          echo -e "${BLUE}════════════════════════════════════════════${NC}"
          echo -e "${BLUE}${BOLD}$1${NC}"
          echo -e "${BLUE}════════════════════════════════════════════${NC}"
      }

      setup_tailscale() {
          log_section "Tailscale Authentication"
          if ! command -v tailscale &>/dev/null; then
              log_warning "Tailscale is not installed. Skipping."
              return 0
          fi
          local status
          status=$(tailscale status 2>&1 || true)
          if [[ "$status" != *"Logged out"* ]] && [[ "$status" != *"not logged in"* ]] && [[ "$status" != *"NeedsLogin"* ]]; then
              log_success "Tailscale already authenticated"
              tailscale status 2>/dev/null | head -5 || true
              return 0
          fi
          log_info "Starting Tailscale authentication..."
          echo "This will open a browser or display a URL to authenticate."
          sudo tailscale up --ssh --advertise-exit-node
          log_success "Tailscale authenticated"
          tailscale status 2>/dev/null | head -5 || true
      }

      setup_git_ssh() {
          log_section "Git SSH Key Setup"
          local ssh_dir="$HOME/.ssh"
          local key_file="$ssh_dir/id_ed25519"
          local pub_key_file="${key_file}.pub"

          if [[ -f "$key_file" ]]; then
              log_success "SSH key already exists: $key_file"
              echo "Public key:"
              cat "$pub_key_file"
          else
              log_info "Generating new SSH key..."
              local email
              email=$(git config --global user.email 2>/dev/null || echo "")
              if [[ -z "$email" ]]; then
                  echo -n "Enter your email for the SSH key: "
                  read -r email
              fi
              mkdir -p "$ssh_dir"
              chmod 700 "$ssh_dir"
              ssh-keygen -t ed25519 -C "$email" -f "$key_file" -N ""
              log_success "SSH key generated"
              echo "Public key:"
              cat "$pub_key_file"
          fi

          eval "$(ssh-agent -s)" &>/dev/null || true
          ssh-add "$key_file" 2>/dev/null || true

          if command -v gh &>/dev/null; then
              log_section "GitHub Authentication"
              if ! gh auth status &>/dev/null; then
                  log_info "Authenticating with GitHub..."
                  gh auth login --web --git-protocol ssh
              else
                  log_success "Already authenticated with GitHub CLI"
              fi
              local hostname
              hostname=$(hostname)
              gh ssh-key add "$pub_key_file" --title "local-remote@${hostname}" 2>/dev/null || log_warning "SSH key may already exist on GitHub"
              log_success "GitHub SSH setup complete"
          else
              log_warning "GitHub CLI (gh) not installed. Add SSH key manually at https://github.com/settings/keys"
          fi
      }

      print_summary() {
          log_section "Setup Complete"
          echo ""
          if command -v tailscale &>/dev/null; then
              echo "  Tailscale: $(tailscale status 2>&1 | head -1 || echo 'unknown')"
          fi
          if [[ -f "$HOME/.ssh/id_ed25519" ]]; then
              echo "  SSH Key: configured"
          fi
          if command -v gh &>/dev/null && gh auth status &>/dev/null; then
              echo "  GitHub: authenticated as $(gh api user -q .login 2>/dev/null || echo 'unknown')"
          fi
          echo ""
          echo "You're all set! Try: git clone git@github.com:your-username/your-repo.git"
      }

      main() {
          echo -e "\n${BOLD}local-remote-login${NC} - Post-login authentication setup\n"
          setup_tailscale
          setup_git_ssh
          print_summary
      }

      main "$@"

  # In-VM verification test script
  # This script runs after cloud-init completes to verify the installation
  - path: /opt/local-remote/test-in-vm.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      # In-VM Verification Script - runs after cloud-init to test installation
      set -u
      RESULTS_FILE="/tmp/test-results.json"
      MARKER_FILE="/tmp/cloud-init-test-complete"
      declare -a TESTS
      PASSED=0
      FAILED=0
      SKIPPED=0

      record_test() {
          local name="$1" status="$2" message="${3:-}"
          message="${message//\"/\\\"}"
          TESTS+=("{\"name\":\"$name\",\"status\":\"$status\",\"message\":\"$message\"}")
          case "$status" in
              pass) ((PASSED++)); echo "[PASS] $name: $message" ;;
              fail) ((FAILED++)); echo "[FAIL] $name: $message" ;;
              skip) ((SKIPPED++)); echo "[SKIP] $name: $message" ;;
          esac
      }

      test_packages() {
          echo "=== Testing packages ==="
          local packages=(git gh docker zsh curl wget jq lazygit lazydocker nvim tmux zellij fzf zoxide rg fd bat delta starship btop yq tailscale)
          for pkg in "${packages[@]}"; do
              if command -v "$pkg" &>/dev/null; then
                  record_test "package:$pkg" "pass" "$("$pkg" --version 2>&1 | head -1 | cut -c1-40)"
              else
                  record_test "package:$pkg" "skip" "not installed"
              fi
          done
      }

      test_git_config() {
          echo "=== Testing git config ==="
          for cfg in user.name user.email init.defaultBranch core.pager; do
              value=$(git config --global "$cfg" 2>/dev/null)
              if [[ -n "$value" ]]; then
                  record_test "git:$cfg" "pass" "$value"
              else
                  record_test "git:$cfg" "skip" "not set"
              fi
          done
      }

      test_shell() {
          echo "=== Testing shell ==="
          [[ "$SHELL" == *"zsh"* ]] && record_test "shell:default" "pass" "zsh" || record_test "shell:default" "fail" "$SHELL"
          [[ -d "$HOME/.oh-my-zsh" ]] && record_test "shell:oh-my-zsh" "pass" "installed" || record_test "shell:oh-my-zsh" "skip" "not installed"
          [[ -f "$HOME/.zshrc" ]] && record_test "shell:zshrc" "pass" "exists" || record_test "shell:zshrc" "fail" "missing"
      }

      test_services() {
          echo "=== Testing services ==="
          systemctl is-active docker &>/dev/null && record_test "service:docker" "pass" "running" || record_test "service:docker" "fail" "not running"
          groups 2>/dev/null | grep -q docker && record_test "service:docker-group" "pass" "in group" || record_test "service:docker-group" "fail" "not in group"
          systemctl is-active tailscaled &>/dev/null && record_test "service:tailscaled" "pass" "running" || record_test "service:tailscaled" "skip" "not running"
      }

      test_dirs() {
          echo "=== Testing directories ==="
          for dir in "$HOME/.config" "$HOME/.local-remote" "$HOME/.local/bin"; do
              [[ -d "$dir" ]] && record_test "dir:$dir" "pass" "exists" || record_test "dir:$dir" "skip" "missing"
          done
      }

      write_results() {
          local tests_json=""
          local first=true
          for test in "${TESTS[@]}"; do
              [[ "$first" == "true" ]] && tests_json="$test" && first=false || tests_json="$tests_json,$test"
          done
          cat > "$RESULTS_FILE" << EOF
      {
        "timestamp": "$(date -Iseconds)",
        "hostname": "$(hostname)",
        "summary": {"total": $((PASSED + FAILED + SKIPPED)), "passed": $PASSED, "failed": $FAILED, "skipped": $SKIPPED},
        "tests": [$tests_json]
      }
      EOF
          echo "Results written to $RESULTS_FILE"
      }

      main() {
          echo "=== Cloud-Init In-VM Verification ==="
          echo "Running as: $(whoami)@$(hostname)"
          test_packages
          test_git_config
          test_shell
          test_services
          test_dirs
          write_results
          touch "$MARKER_FILE"
          echo "=== Tests complete: $PASSED passed, $FAILED failed, $SKIPPED skipped ==="
          [[ $FAILED -eq 0 ]]
      }

      main "$@"

# =============================================================================
# Run Commands
# =============================================================================

runcmd:
  # Install Docker
  - |
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" > /etc/apt/sources.list.d/docker.list
    apt-get update
    apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
    usermod -aG docker ${USERNAME}
    systemctl enable docker

  # Install GitHub CLI
  - |
    curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | dd of=/etc/apt/keyrings/githubcli-archive-keyring.gpg
    chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" > /etc/apt/sources.list.d/github-cli.list
    apt-get update
    apt-get install -y gh

  # Install Tailscale
  - |
    curl -fsSL https://tailscale.com/install.sh | sh
    systemctl enable tailscaled
    systemctl start tailscaled

  # Authenticate Tailscale (if auth key provided)
  - bash /opt/local-remote/setup-tailscale.sh

  # Fix ownership of user directories created by cloud-init
  - mkdir -p /home/${USERNAME}/.local-remote/logs /home/${USERNAME}/.config
  - chown -R ${USERNAME}:${USERNAME} /home/${USERNAME}/.local-remote /home/${USERNAME}/.config

  # Run bootstrap script
  - /opt/local-remote/bootstrap.sh

  # Cleanup
  - rm -f /home/${USERNAME}/.local-remote/tailscale-auth-key

  # Run verification tests (for automated testing)
  - bash -c 'if [ -f /opt/local-remote/test-in-vm.sh ]; then echo "=== Running verification tests ==="; sudo -u ${USERNAME} /opt/local-remote/test-in-vm.sh || true; fi'

# =============================================================================
# Final Message
# =============================================================================

final_message: |
  === Cloud-Init Complete ===

  System: ${HOSTNAME}
  User: ${USERNAME}

  Installation completed in $UPTIME seconds.

  Next steps:
  1. SSH: ssh ${USERNAME}@<ip-address>
  2. Run 'local-remote-login' to set up Tailscale and GitHub SSH
  3. Run 'make verify-cloud' to verify installation

  Logs: /var/log/cloud-init-output.log
